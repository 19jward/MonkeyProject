---
title: "Function Development"
author: "Josephine Ward"
date: "2025-02-10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TOC
* I. Packages
* II. Transition Matrix from an Individual Focal
* III. New Function: Get Log-Likelihood
  - III.1 Pseudo-Code
  - III.2 Code Attempts
* IV. New Function: Get Behaviors
  - IV.1 Pseudo-Code

# I. Packages

```{r}

```


# II. Transition Matrix from an Individual Focal

```{r}
behaviorshortlist <-c("Move", "Vigilance", "Feed", "Rest",
               "Affiliative", "Aggressive", "SelfGroom",
               "Survey", "PAUSE", "Human Directed",
               "Forage", "Sleep", "Play")

matrixfunct <- function(dataframe, behaviorshortlist){
  Matrix <- matrix(NA, nrow = length(behaviorshortlist), ncol = length(behaviorshortlist))
  rownames(Matrix) <- colnames(Matrix) <- behaviorshortlist
  for(b1 in behaviorshortlist){
    denomentator <- sum(dataframe$TimeSpent[dataframe$Behavior == b1]) - 
      as.numeric(tail(dataframe$Behavior, 1) == b1) ## accounting for if the last behavior in focal is b1 (doesn't count as a transition opportunity), overall total possible transition opportunities
    b1_ind <- which(dataframe$Behavior == b1)
    for(b2 in behaviorshortlist){
      if(b1 == b2){ ## if staying in the same behavior
        numerator <- denomentator - sum(dataframe$Behavior == b1) + 
          as.numeric(tail(dataframe$Behavior, 1) == b1) 
        ## removing the times they switched to a diff behavior & adding back in that situation if the last behavior is b1
        } else { ## if moving to a different behavior
          numerator <- sum(dataframe$Behavior[b1_ind + 1] == b2, na.rm = T)
          }
      Matrix[b1,b2] <- numerator/denomentator
    }
  }
return(Matrix)
}

Matrix <- matrixfunct(focal28, behaviorshortlist)
rowSums(Matrix)
Matrix
```

** NOTE: this does not work when we have the situation where the data file has 2 of the same behavior right on top of eachother --> probably easier to fix by cleaning the dataframe than changing the function (also we never concretely established why it is like that in the data)


** future consideration: how to make this apply to multiple combined focals
** also make it more generalizable than the specific names I have going on here


# III. Get Log-Likelihood Function

## III.1 Pseudo-Code/Work
- get log-likelihood function (the spacing on this will probably look wack when i knit but thats life)
_______________________________________________________
Outline from Henry:
P = the probability transition matrix?

get_LL --> function(behaviors, P){
  .
  .
  .
  return(log-likelihood)
}
Check:
If you’ve made behaviors w/particular P, does it give you close to the highest possible value with the first function
1. Simulate behaviors from P
2. Check get_LL is maximized close to P
Then optim function will help us with maximization

________________________________________________________________________

so we want the likelhood --> probability of being in any particular behavior (function of parameters given data)

so this function needs to take in data and calculate probability of being in each of the behaviors


optim() function for optimization (so like do the derivative part for me once i have the equation?)

toy examples for the package (vignettes)

___________________________________________________________________________
work w/Henry during the meeting:

y1 = behavior at first time point
y1| p1 ~ categorical w/probability p1= (p11, p12, ..., p1B) B = 13/ whatever the number of behaviors are
  p1 = probabilkty of being in which of the B behaviors when you wander out and see the monkeys

P = transition matrix 

yt = ( 0 0 0 ...... 1 ...... 0 0 0)^T bth behavior

yt|[y(t-1), P ] ~ cat(Py(t-1)) ~ Cat(pt)

pt = P*y(t-1) --> picks out particular row of P

holds for t2 --> B

so now we can find the likelihood
things:
- categorical --> pmf not pdf
- not independent 

L(theta, y) = P(y1|p1)P(y2|y1, P)P(y3|y2, P) .....
            = P(y1|p1)*product(P(yt|y(t-1), P))
            
            inner product of y1^t*p1
            (y1^t*p1)(yT*P*y(T-1)).....(y2*P*y(2-1))
            
we prefer log

log(L) = sum of logs = log(y1^t*p1) + log(yT*P*y(T-1)) + ......

P(y1|p1) = P11 ^ y11 * P12^y12 * ..... * P1B^y1B
log(^^) = y1^tlog(p1)

need to like expand the data so it has each second as individual 

output is a single scalar (not a matrix)

essentially doing this to test different Ps

then we optimize that function to find the Ps


test function , give it a P, tells us how good we are doing

checks we can do:

take a focal, take one of the point estimated matrices, do the log-likelihood, try it again with a diff transition matrix, likelihood value should go down

P = matrix(p11, p12, p13, p21, p22, p23, p31, p32, p33, row = 3, col = 3)
but what if p12 = beta0 + beta1(X=indicator for forest)
probably have to do logit and make sure the ps all sum to 1 still? idk 
so we take our function and tweak it to have betas instead of Ps
___________________________________________________________________________
## III.2 Code Attempts
```{r}
## so this function takes in some data (like a focal basically) in the form of a list of behaviors
## also takes P, a transition matrix, probability of going from one behavior to the next
get_LL <- function(data, P){
  # y1 <- first listed behavior
  # p1 <- probabilty of starting behavior
  # yt <-  = ( 0 0 ... 1 .... 0 0) where the 1 tells us which behavior it is, goes to B
  
  ## pick out a particular row of P (a vector of probabilities)
  ## this holds for behavior = 2 --> B (where B is the last listed behavior)
  # pt <- probability of going to a behavior at time t = P*y(t-1)
  
  
  ## define likelihood function
  # L(theta, y) = P(y1|p1)P(y2|y1, P)P(y3|y2, P) .....
  #          = P(y1|p1)*product(P(yt|y(t-1), P))
            
  #          inner product of y1^t*p1
  #          (y1^t*p1)(yT*P*y(T-1)).....(y2*P*y(2-1))
  
  ## make it a log-likelihood
  # LogL <- log(L) = sum of logs = log(y1^t*p1) + log(yT*P*y(T-1)) + ......
  # P(y1|p1) = P11 ^ y11 * P12^y12 * ..... * P1B^y1B
  # log(^^) = y1^tlog(p1)
  
  return(LogL)
}
```
- where to use data?

# IV. Get Behaviors

## IV.1 Pseudo-Code

from henry:

get_behaviors —> function(P, initial_behavior){
	.
	.
	.
	return(Behaviors)}
