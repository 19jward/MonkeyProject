---
title: "Function Development"
author: "Josephine Ward"
date: "2025-02-10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TOC
* I. Packages
* II. Transition Matrix from an Individual Focal
* III. New Function: Get Log-Likelihood
  - III.1 Pseudo-Code
  - III.2 Code Attempts/notes idk
* IV. Isolate Focal Function

# I. Packages

```{r}
library(dplyr) ## need for case_when in get_ll function
```

## data import

```{r}
monkeyprelimdata <- read.csv("~/Desktop/MonkeyProject/monkeyprelimdata.csv")
```

# II. Transition Matrix from an Individual Focal

```{r}
behaviorshortlist <-c("Move", "Vigilance", "Feed", "Rest",
               "Affiliative", "Aggressive", "SelfGroom",
               "Survey", "Human Directed",
               "Forage", "Sleep", "Play")

matrixfunct <- function(dataframe, behaviorshortlist){
  Matrix <- matrix(NA, nrow = length(behaviorshortlist), ncol = length(behaviorshortlist))
  rownames(Matrix) <- colnames(Matrix) <- behaviorshortlist
  for(b1 in behaviorshortlist){
    denomentator <- sum(dataframe$TimeSpent[dataframe$Behavior == b1]) - 
      as.numeric(tail(dataframe$Behavior, 1) == b1) ## accounting for if the last behavior in focal is b1 (doesn't count as a transition opportunity), overall total possible transition opportunities
    b1_ind <- which(dataframe$Behavior == b1)
    for(b2 in behaviorshortlist){
      if(b1 == b2){ ## if staying in the same behavior
        numerator <- denomentator - sum(dataframe$Behavior == b1) + 
          as.numeric(tail(dataframe$Behavior, 1) == b1) 
        ## removing the times they switched to a diff behavior & adding back in that situation if the last behavior is b1
        } else { ## if moving to a different behavior
          numerator <- sum(dataframe$Behavior[b1_ind + 1] == b2, na.rm = T)
          }
      Matrix[b1,b2] <- numerator/denomentator
    }
  }
return(Matrix)
}
```

** NOTE: this does not work when we have the situation where the data file has 2 of the same behavior right on top of eachother --> probably easier to fix by cleaning the dataframe than changing the function (also we never concretely established why it is like that in the data)


** future consideration: how to make this apply to multiple combined focals
** also make it more generalizable than the specific names I have going on here


# III. Get Log-Likelihood Function

## III.1 Pseudo-Code/Work
- get log-likelihood function (the spacing on this will probably look wack when i knit but thats life)
_______________________________________________________
Outline from Henry:
P = the probability transition matrix?

get_LL --> function(behaviors, P){
  .
  .
  .
  return(log-likelihood)
}
Check:
If youâ€™ve made behaviors w/particular P, does it give you close to the highest possible value with the first function
1. Simulate behaviors from P
2. Check get_LL is maximized close to P
Then optim function will help us with maximization

________________________________________________________________________

so we want the likelhood --> probability of being in any particular behavior (function of parameters given data)

so this function needs to take in data and calculate probability of being in each of the behaviors


optim() function for optimization (so like do the derivative part for me once i have the equation?)

toy examples for the package (vignettes)

___________________________________________________________________________
work w/Henry during the meeting:

y1 = behavior at first time point
y1| p1 ~ categorical w/probability p1= (p11, p12, ..., p1B) B = 13/ whatever the number of behaviors are
  p1 = probabilkty of being in which of the B behaviors when you wander out and see the monkeys

P = transition matrix 

yt = ( 0 0 0 ...... 1 ...... 0 0 0)^T bth behavior

yt|[y(t-1), P ] ~ cat(Py(t-1)) ~ Cat(pt)

pt = P*y(t-1) --> picks out particular row of P

holds for t2 --> B

so now we can find the likelihood
things:
- categorical --> pmf not pdf
- not independent 

L(theta, y) = P(y1|p1)P(y2|y1, P)P(y3|y2, P) .....
            = P(y1|p1)*product(P(yt|y(t-1), P))
            
            inner product of y1^t*p1
            (y1^t*p1)(yT*P*y(T-1)).....(y2*P*y(2-1))
            
we prefer log

log(L) = sum of logs = log(y1^t*p1) + log(yT*P*y(T-1)) + ......

P(y1|p1) = P11 ^ y11 * P12^y12 * ..... * P1B^y1B
log(^^) = y1^tlog(p1)

need to like expand the data so it has each second as individual 

output is a single scalar (not a matrix)

essentially doing this to test different Ps

then we optimize that function to find the Ps


test function , give it a P, tells us how good we are doing

checks we can do:

take a focal, take one of the point estimated matrices, do the log-likelihood, try it again with a diff transition matrix, likelihood value should go down

P = matrix(p11, p12, p13, p21, p22, p23, p31, p32, p33, row = 3, col = 3)
but what if p12 = beta0 + beta1(X=indicator for forest)
probably have to do logit and make sure the ps all sum to 1 still? idk 
so we take our function and tweak it to have betas instead of Ps
___________________________________________________________________________
## III.2 Code Attempts
```{r}
## so this function takes in some data (like a focal basically) in the form of a list of behaviors
## also takes P, a transition matrix, probability of going from one behavior to the next

## i think i need the data to be each second to be a row in the data frame otherwise this wont work (but that would break the function to get P so needs to be done separate? maybe within the function if possible)

get_LL <- function(data, P){
  B <- nrow(P) # number of behaviors
  focal_length <- length(data) # number of seconds in focal (if i set it up right)
  
  ## create dummy variable vector for behaviors (0s and 1 corresponding to which behavior we are at)
  # probably could do this with a for loop but like problem for later
  # this was so not efficient and IMPORTANT: behaviorlist needs to be in the same order as mine
  for(t in 2:focal_length){
    y <- c()
    ### i need to like define p or something here
    y[1] <- data$Behavior[1] # first listed behavior in the provided data
    p[1] <- c(rep(1/12, 12)) #probability of starting behavior (doing uniform for now)
    case_when(
      data$Behavior[t] == "Move" - ~  y <- c(1,0,0,0,0,0,0,0,0,0,0,0), 
      data$Behavior[t] == "Vigilance" ~  y <- c(0,1,0,0,0,0,0,0,0,0,0,0),
      data$Behavior[t] == "Feed" ~  y <- c(0,0,1,0,0,0,0,0,0,0,0,0),
      data$Behavior[t] == "Rest" ~  y <- c(0,0,0,1,0,0,0,0,0,0,0,0),
      data$Behavior[t] == "Affiliative" ~  y <- c(0,0,0,0,1,0,0,0,0,0,0,0),
      data$Behavior[t] == "Aggresive" ~  y <- c(0,0,0,0,0,1,0,0,0,0,0,0),
      data$Behavior[t] == "SelfGroom" ~  y <- c(0,0,0,0,0,0,1,0,0,0,0,0),
      data$Behavior[t] == "Survey" ~  y <- c(0,0,0,0,0,0,0,1,0,0,0,0),
      data$Behavior[t] == "Human Directed" ~  y <- c(0,0,0,0,0,0,0,0,1,0,0,0),
      data$Behavior[t] == "Forage" ~  y <- c(0,0,0,0,0,0,0,0,0,1,0,0),
      data$Behavior[t] == "Sleep" ~  y <- c(0,0,0,0,0,0,0,0,0,0,1,0),
      data$Behavior[t] == "Play" ~  y <- c(0,0,0,0,0,0,0,0,0,0,0,1),
    )
    # pick out a particular row of P
    p[t] <- P*y[t-1]
    
    # define log-likelihood function
    LogL <- t(y[1])*log(p[1]) ## initialize it
    LogL <- LogL + t(y[t])*log(p[t])
  }
  return(LogL)
}

## still have the problem with taking log(0) .....
```

New problems to discuss with Henry:
- i'm having an issue defining p? i think im just missing like one line to initialize p
- is the log(0) thing an actual problem or am i being silly and not conceptually understanding likelihood
- recommendations on how to reformat the data to give it second by second? or would it be easier to change it by behavior rather than second? is that a function worth having? i dont think it should be too hard to just change it by behavior i think
- are we still working with discrete markov chains? i feel like the goal at some point was to make it continous?
- am i good to use other packages within this or were we trying to make functions that dont rely on any other package?


Notes:
 ## define likelihood function
  # L(theta, y) = P(y1|p1)P(y2|y1, P)P(y3|y2, P) .....
  #          = P(y1|p1)*product(P(yt|y(t-1), P))
            
  #          inner product of y1^t*p1
  #          (y1^t*p1)(yT*P*y(T-1)).....(y2*P*y(2-1))
  
  ## make it a log-likelihood
  # LogL <- log(L) = sum of logs = log(y1^t*p1) + log(yT*P*y(T-1)) + ......
  # P(y1|p1) = P11 ^ y11 * P12^y12 * ..... * P1B^y1B
  # log(^^) = y1^tlog(p1)
  


```{r}
## ok im gonna train it on focal 28 and then use focal 10 as the input data?

P_28 <- matrixfunct(focal_28, behaviorshortlist)
P_28
P_28[is.na(P_28)] <- 0 ## get rid of NaNs

focal_10 <- isolate.focal(10)
P_10 <- matrixfunct(focal_10, behaviorshortlist)

```


- can also test this using the same focal with the same P and should give highest you can get
  
- combine some focals? get more transitions?

#### Resolved things (that arent really resolved but im kinda just ignoring for now):

- like somewhere there is supposed to be a part where i can put some variables like forest/road or whatever and that is included in the likelihood? im not sure where to put this
  -ignore this for now (which will replace the ps with betas in the future)
-overall NaNs from P to 0s to make it work (for now, dont change the matrixfunct function)

- pause? remove but dont want the next to be a transition?
  - change og function to ignore PAUSE
  - chop off focals after point of PAUSE (lose some data)
  - split into multiple focals?
  - choose path of least resistance rn
  - for rn im just going to choose focals that dont have PAUSE and i will deal with that later :)
____________________________________________________
work w/Henry:

- trying to simplify the log likelihood equation to avoid a really long for loop?
- p20 in the reference book
- change from adding over to adding over behavior?
- each probability raised to the power of number of transitions (some will be 0 = 1)
- can do each second or do it count of transitions 
- (i took a picture of what henry wrote on the board so reference that as you go)

	
## IV. Isolate focal function
```{r}
## function to isolate a single focal & add a cumulative time column
isolate.focal <- function(i){
  onefocal.i <- subset(monkeyprelimdata, monkeyprelimdata$FocalID == i)
  cumsum.i <- data.frame(cumsum(onefocal.i$TimeSpent))
  onefocal.i <- cbind(onefocal.i, cumsum.i)
  return(onefocal.i)
}

# test
focal_28 <- isolate.focal(28)
```
