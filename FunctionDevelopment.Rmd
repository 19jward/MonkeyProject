---
title: "Function Development"
author: "Josephine Ward"
date: "2025-02-10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TOC
* I. Packages
* II. Transition Matrix from an Individual Focal
* III. New Function: Get Log-Likelihood
  - III.1 Pseudo-Code
  - III.2 Code Attempts
* IV. New Function: Get Behaviors
  - IV.1 Pseudo-Code
* V. Isolate Focal Function

# I. Packages

```{r}
library(dplyr)
```

## data import

```{r}
monkeyprelimdata <- read.csv("~/Desktop/MonkeyProject/monkeyprelimdata.csv")
```

# II. Transition Matrix from an Individual Focal

```{r}
behaviorshortlist <-c("Move", "Vigilance", "Feed", "Rest",
               "Affiliative", "Aggressive", "SelfGroom",
               "Survey", "Human Directed",
               "Forage", "Sleep", "Play")

matrixfunct <- function(dataframe, behaviorshortlist){
  Matrix <- matrix(NA, nrow = length(behaviorshortlist), ncol = length(behaviorshortlist))
  rownames(Matrix) <- colnames(Matrix) <- behaviorshortlist
  for(b1 in behaviorshortlist){
    denomentator <- sum(dataframe$TimeSpent[dataframe$Behavior == b1]) - 
      as.numeric(tail(dataframe$Behavior, 1) == b1) ## accounting for if the last behavior in focal is b1 (doesn't count as a transition opportunity), overall total possible transition opportunities
    b1_ind <- which(dataframe$Behavior == b1)
    for(b2 in behaviorshortlist){
      if(b1 == b2){ ## if staying in the same behavior
        numerator <- denomentator - sum(dataframe$Behavior == b1) + 
          as.numeric(tail(dataframe$Behavior, 1) == b1) 
        ## removing the times they switched to a diff behavior & adding back in that situation if the last behavior is b1
        } else { ## if moving to a different behavior
          numerator <- sum(dataframe$Behavior[b1_ind + 1] == b2, na.rm = T)
          }
      Matrix[b1,b2] <- numerator/denomentator
    }
  }
return(Matrix)
}
```

** NOTE: this does not work when we have the situation where the data file has 2 of the same behavior right on top of eachother --> probably easier to fix by cleaning the dataframe than changing the function (also we never concretely established why it is like that in the data)


** future consideration: how to make this apply to multiple combined focals
** also make it more generalizable than the specific names I have going on here


# III. Get Log-Likelihood Function

## III.1 Pseudo-Code/Work
- get log-likelihood function (the spacing on this will probably look wack when i knit but thats life)
_______________________________________________________
Outline from Henry:
P = the probability transition matrix?

get_LL --> function(behaviors, P){
  .
  .
  .
  return(log-likelihood)
}
Check:
If youâ€™ve made behaviors w/particular P, does it give you close to the highest possible value with the first function
1. Simulate behaviors from P
2. Check get_LL is maximized close to P
Then optim function will help us with maximization

________________________________________________________________________

so we want the likelhood --> probability of being in any particular behavior (function of parameters given data)

so this function needs to take in data and calculate probability of being in each of the behaviors


optim() function for optimization (so like do the derivative part for me once i have the equation?)

toy examples for the package (vignettes)

___________________________________________________________________________
work w/Henry during the meeting:

y1 = behavior at first time point
y1| p1 ~ categorical w/probability p1= (p11, p12, ..., p1B) B = 13/ whatever the number of behaviors are
  p1 = probabilkty of being in which of the B behaviors when you wander out and see the monkeys

P = transition matrix 

yt = ( 0 0 0 ...... 1 ...... 0 0 0)^T bth behavior

yt|[y(t-1), P ] ~ cat(Py(t-1)) ~ Cat(pt)

pt = P*y(t-1) --> picks out particular row of P

holds for t2 --> B

so now we can find the likelihood
things:
- categorical --> pmf not pdf
- not independent 

L(theta, y) = P(y1|p1)P(y2|y1, P)P(y3|y2, P) .....
            = P(y1|p1)*product(P(yt|y(t-1), P))
            
            inner product of y1^t*p1
            (y1^t*p1)(yT*P*y(T-1)).....(y2*P*y(2-1))
            
we prefer log

log(L) = sum of logs = log(y1^t*p1) + log(yT*P*y(T-1)) + ......

P(y1|p1) = P11 ^ y11 * P12^y12 * ..... * P1B^y1B
log(^^) = y1^tlog(p1)

need to like expand the data so it has each second as individual 

output is a single scalar (not a matrix)

essentially doing this to test different Ps

then we optimize that function to find the Ps


test function , give it a P, tells us how good we are doing

checks we can do:

take a focal, take one of the point estimated matrices, do the log-likelihood, try it again with a diff transition matrix, likelihood value should go down

P = matrix(p11, p12, p13, p21, p22, p23, p31, p32, p33, row = 3, col = 3)
but what if p12 = beta0 + beta1(X=indicator for forest)
probably have to do logit and make sure the ps all sum to 1 still? idk 
so we take our function and tweak it to have betas instead of Ps
___________________________________________________________________________
## III.2 Code Attempts
```{r}
## so this function takes in some data (like a focal basically) in the form of a list of behaviors
## also takes P, a transition matrix, probability of going from one behavior to the next

## i think i need the data to be each second to be a row in the data frame otherwise this wont work (but that would break the function to get P so needs to be done separate? maybe within the function if possible)

get_LL <- function(data, P){
  B <- nrow(P) # number of behaviors
  focal_length <- length(data) # number of seconds in focal (if i set it up right)
  
  ## create dummy variable vector for behaviors (0s and 1 corresponding to which behavior we are at)
  # probably could do this with a for loop but like problem for later
  # this was so not efficient and IMPORTANT: behaviorlist needs to be in the same order as mine
  for(t in 2:focal_length){
    y <- c()
    y[1] <- data$Behavior[1] # first listed behavior in the provided data
    p[1] <- c(rep(1/12, 12)) #probability of starting behavior (doing uniform for now)
    case_when(
      data$Behavior[t] == "Move" - ~  y <- c(1,0,0,0,0,0,0,0,0,0,0,0), 
      data$Behavior[t] == "Vigilance" ~  y <- c(0,1,0,0,0,0,0,0,0,0,0,0),
      data$Behavior[t] == "Feed" ~  y <- c(0,0,1,0,0,0,0,0,0,0,0,0),
      data$Behavior[t] == "Rest" ~  y <- c(0,0,0,1,0,0,0,0,0,0,0,0),
      data$Behavior[t] == "Affiliative" ~  y <- c(0,0,0,0,1,0,0,0,0,0,0,0),
      data$Behavior[t] == "Aggresive" ~  y <- c(0,0,0,0,0,1,0,0,0,0,0,0),
      data$Behavior[t] == "SelfGroom" ~  y <- c(0,0,0,0,0,0,1,0,0,0,0,0),
      data$Behavior[t] == "Survey" ~  y <- c(0,0,0,0,0,0,0,1,0,0,0,0),
      data$Behavior[t] == "Human Directed" ~  y <- c(0,0,0,0,0,0,0,0,1,0,0,0),
      data$Behavior[t] == "Forage" ~  y <- c(0,0,0,0,0,0,0,0,0,1,0,0),
      data$Behavior[t] == "Sleep" ~  y <- c(0,0,0,0,0,0,0,0,0,0,1,0),
      data$Behavior[t] == "Play" ~  y <- c(0,0,0,0,0,0,0,0,0,0,0,1),
    )
    # pick out a particular row of P
    p[t] <- P*y[t-1]
    
    # define log-likelihood function
    LogL <- t(y[1])*log(p[1]) ## initialize it
    LogL <- LogL + t(y[t])*log(p[t])
  }
  return(LogL)
}

## still have the problem with taking log(0) from my other attempt.....
```


 ## define likelihood function
  # L(theta, y) = P(y1|p1)P(y2|y1, P)P(y3|y2, P) .....
  #          = P(y1|p1)*product(P(yt|y(t-1), P))
            
  #          inner product of y1^t*p1
  #          (y1^t*p1)(yT*P*y(T-1)).....(y2*P*y(2-1))
  
  ## make it a log-likelihood
  # LogL <- log(L) = sum of logs = log(y1^t*p1) + log(yT*P*y(T-1)) + ......
  # P(y1|p1) = P11 ^ y11 * P12^y12 * ..... * P1B^y1B
  # log(^^) = y1^tlog(p1)
  
```{r}
## i got lost in the sauce i'm gonna try something way simpler? see if it works?
# i think this would maybe work if i can get a function to automatically expand the duration to just 1 second over and over

## so this is not working for many reasons but idk if this is a simpler base to troubleshoot from but im just gonna leave that here and try the other one again

get_LL.2 <- function(data, P){
  B <- nrow(P) # number of behaviors
  focal_length <- length(data) # number of seconds in focal (if i set it up right)
  
  
  for(t in 2:focal_length){
    current_state <- data$Behavior[t-1]
    next_state <- data$Behavior[t]
    
    trans_prob <- P[current_state, next_state] #i dont think its set up like this rn w/names in P
    
    ll_value <- 0 #start
    ll_value <- ll_value + log(trans_prob) ## problem with taking log of 0
  }
  return(ll_value)
}

# so i lost p1 somewhere in there i think
# also feel like i should have used my B? oh wait that's what i would use if i didnt split up the seconds thing and instead utilized duration

```



```{r}
## ok im gonna train it on focal 28 and then use focal 10 as the input data?

P_28 <- matrixfunct(focal_28, behaviorshortlist)
P_28
P_28[is.na(P_28)] <- 0 ## get rid of NaNs

focal_10 <- isolate.focal(10)
P_10 <- matrixfunct(focal_10, behaviorshortlist)

get_LL.2(focal_10, P_28) ## didnt work 
  ## are the NAs a problem?
  ## i got rid of them and it still didnt work
  ## taking log of 0? undefined? yeah thats the problem
```


- is t the index for the for loop?
  -not most efficient but sure (time second by second)

-for loop to define pt?

- can also test this using the same focal with the same P and should give highest you can get



- like somewhere there is supposed to be a part where i can put some variables like forest/road or whatever and that is included in the likelihood? im not sure where to put this
  -ignore this for now (which will replace the ps with betas in the future)
  
- combine some focals? get more transitions?

-overall NaNs from P to 0s to make it work (for now, dont change the matrixfunct function)

- pause? remove but dont want the next to be a transition?
  - change og function to ignore PAUSE
  - chop off focals after point of PAUSE (lose some data)
  - split into multiple focals?
  - choose path of least resistance rn
  - for rn im just going to choose focals that dont have PAUSE and i will deal with that later :)
____________________________________________________
work w/Henry:

- trying to simplify the log likelihood equation to avoid a really long for loop?
- p20 in the reference book
- change from adding over to adding over behavior?
- each probability raised to the power of number of transitions (some will be 0 = 1)
- can do each second or do it count of transitions 
- (i took a picture of what henry wrote on the board so reference that as you go)


- looking at initial probabilty 
- 

# IV. Get Behaviors

## IV.1 Pseudo-Code

from henry:

get_behaviors â€”> function(P, initial_behavior){
	.
	.
	.
	return(Behaviors)}
	
## V. Isolate focal function
```{r}
## function to isolate a single focal & add a cumulative time column
isolate.focal <- function(i){
  onefocal.i <- subset(monkeyprelimdata, monkeyprelimdata$FocalID == i)
  cumsum.i <- data.frame(cumsum(onefocal.i$TimeSpent))
  onefocal.i <- cbind(onefocal.i, cumsum.i)
  return(onefocal.i)
}

# test
focal_28 <- isolate.focal(28)
```
