---
title: "Function Development"
author: "Josephine Ward"
date: "2025-02-10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

_____________________________________________________________________________

# TOC
* 0. Data Import
* I. Unresolved Stuff to Consider
* II. Transition Matrix from an Individual Focal
* III. New Function: Get Log-Likelihood
  - III.1 Pseudo-Code/Notes
  - III.2 Function Code
  - III.3 Testing get_LL function
* IV. Isolate Focal Function
* V. Optimizing LL
  - V.1 Notes
  - V.2 Function Code
  - V.3 Testing/Applying Function
* VI. get_ll_row 
  - VI.1 Function
  - VI.2 Testing Function
* VII. Optimizing by row (replace fit_MM)
  - VII.1 Function Code
  - VII.2 Testing (but also just use V.III)
* VIII. Adding Covariates

__________________________________________________________________________

# 0. data import

```{r}
monkeyprelimdata <- read.csv("~/Desktop/MonkeyProject/monkeyprelimdata.csv")

full_behavior_list <-c("Move", "Vigilance", "Feed", "Rest",
               "Affiliative", "Aggressive", "SelfGroom",
               "Survey", "Human Directed",
               "Forage", "Sleep", "Play")
```

____________________________________________________________________________

# I. Unresolved Stuff to Consider

* combining focals
  - how to apply transition matrix to focal combos
  - accounting for the jump from focal to focal not actually being a transition
* pause? remove but dont want the next to be a transition?
  - change og function to ignore PAUSE
  - chop off focals after point of PAUSE (lose some data)
  - split into multiple focals?
  - choose path of least resistance rn
  - for rn im just going to choose focals that dont have PAUSE and i will deal with that
  later :)
* add uncertainty to optmization (confidence intervals?)
____________________________________________________________________________

# II. Transition Matrix from an Individual Focal

Function for creating a point estimate transition matrix for a singulat focal
\
\
NOTE: columns need to be named "TimeSpent" and "Behavior"
\
\
function takes a dataset (focal) and a list of behaviors
```{r}
matrixfunct <- function(data, behavior_list){
  Matrix <- matrix(NA, nrow = length(behavior_list), ncol = length(behavior_list))
  rownames(Matrix) <- colnames(Matrix) <- behavior_list
  for(b1 in behavior_list){
    denomentator <- sum(dataframe$TimeSpent[data$Behavior == b1]) - 
      as.numeric(tail(data$Behavior, 1) == b1) ## accounting for if the last behavior in focal is b1 (doesn't count as a transition opportunity), overall total possible transition opportunities
    b1_ind <- which(data$Behavior == b1)
    for(b2 in behavior_list){
      if(b1 == b2){ ## if staying in the same behavior
        numerator <- denomentator - sum(data$Behavior == b1) + 
          as.numeric(tail(data$Behavior, 1) == b1) 
        ## removing the times they switched to a diff behavior & adding back in that     situation if the last behavior is b1
        } else { ## if moving to a different behavior
          numerator <- sum(data$Behavior[b1_ind + 1] == b2, na.rm = T)
          }
      Matrix[b1,b2] <- numerator/denomentator
    }
  }
return(Matrix)
}
```

** NOTE: this does not work when we have the situation where the data file has 2 of the same behavior right on top of eachother --> probably easier to fix by cleaning the dataframe than changing the function (also we never concretely established why it is like that in the data)

___________________________________________________________________________

# III. Get Log-Likelihood Function

## III.1 Pseudo-Code/Work

work w/Henry during the meeting:

L(theta, y) = P(y1|p1)P(y2|y1, P)P(y3|y2, P) .....
            = P(y1|p1)*product(P(yt|y(t-1), P))
            
            inner product of y1^t*p1
            (y1^t*p1)(yT*P*y(T-1)).....(y2*P*y(2-1))
            
we prefer log -->

log(L) = sum of logs = log(y1^t*p1) + log(yT*P*y(T-1)) + ......

P(y1|p1) = P11 ^ y11 * P12^y12 * ..... * P1B^y1B
log(^^) = y1^tlog(p1)


P = matrix(p11, p12, p13, p21, p22, p23, p31, p32, p33, row = 3, col = 3)
but what if p12 = beta0 + beta1(X=indicator for forest)
probably have to do logit and make sure the ps all sum to 1 still? idk 
so we take our function and tweak it to have betas instead of Ps

___________________________________________________________________________

## III.2 Code (get_LL)
```{r}
## functions takes data (a focal) and P (a transition matrix)
## note column names need to be "TimeSpent" and "Behavior"
get_ll <- function(data, P, behavior_list){
  ## build a Y Duration Matrix (which is just P without the denominator)
  Yduration <- matrix(NA, nrow = length(behavior_list), ncol = length(behavior_list))
  rownames(Yduration) <- colnames(Yduration) <- behavior_list
  for(b1 in behavior_list){
    denominator <- sum(data$TimeSpent[data$Behavior == b1]) - 
      as.numeric(tail(data$Behavior, 1) == b1)
    b1_ind <- which(data$Behavior == b1)
    for(b2 in behavior_list){
      if(b1 == b2){
        numerator <- denominator - sum(data$Behavior == b1) + 
          as.numeric(tail(data$Behavior, 1) == b1) 
        } else { 
          numerator <- sum(data$Behavior[b1_ind + 1] == b2, na.rm = T)
          }
      Yduration[b1,b2] <- numerator
    }
  }
  
  LogL <- sum((log(P)*Yduration)[Yduration>0])
  
  if(is.na(LogL)){
    return(-Inf)
  } else {
    return(LogL)
  }
}
```

## III.3 Testing
```{r}
## ok im gonna train it on focal 28 and then use focal 10 as the input data?

P_28 <- matrixfunct(focal_28, behaviorshortlist)
P_28
P_28[is.na(P_28)] <- 0 ## get rid of NaNs

focal_10 <- isolate.focal(10)
P_10 <- matrixfunct(focal_10, behaviorshortlist)
P_10[is.na(P_10)] <- 0 ## get rid of NaNs

get_ll(focal_10, P_28) 

get_ll(focal_10, P_10)

P_fake <- matrix(1/12, 12, 12) ## cant have 0 probability for a transition that we do observe - shouldnt happen in the real full set
focal_1 <- isolate.focal(1)

get_ll(focal_1, P_fake)
```

___________________________________________________________________
	
## IV. Isolate focal function
```{r}
## function to isolate a single focal & add a cumulative time column
## only really works with my specific data & names
## (useful for testing functions, not really for any actual analysis)

isolate.focal <- function(data, i){
  onefocal.i <- subset(data, data$FocalID == i)
  cumsum.i <- data.frame(cumsum(onefocal.i$TimeSpent))
  onefocal.i <- cbind(onefocal.i, cumsum.i)
  return(onefocal.i)
}

# test
focal_28 <- isolate.focal(monkeyprelimdata, 28)
```


__________________________________________________________________________

# V. Optimizing LL

## V.1 Notes

```{r}
## rough sketch from henry
get_ll.h <- function(X, mu, sigma){
  if(sigma < 0) return(-Inf)
  sum(dnorm(X, mean = mu, sd = sigma, log = T))
}

get_ll.h(c(1, 2, 3, 4), mu = 2.3, sigma = 1)

fit.h <- optim(par = c(0, 5), fn = function(par, X){
  get_ll.h(X, mu = par[1], sigma = par[2])
}, X = c(1, 2, 3, 4), control = c(fnscale = -1))

fit.h

```

```{r}
## set up 

## fake dataset (3 behaviors only)

fake_behaviors <- c("move", "feed", "move", "sleep", "feed", "sleep", "move", "sleep", "move")
fake_duration <- c(5, 10, 4, 102, 16, 58, 14, 9, 11) 
X <- fake_data <- data.frame(fake_duration, fake_behaviors)
colnames(X) <- colnames(fake_data) <- c("TimeSpent", "Behavior") ## match my fake one to work with the matrixfunctions

fake_behaviorshortlist <- c("move", "sleep", "feed")
Pf <- matrixfunct(X, fake_behaviorshortlist) ## transition matrix of fake focal

get_ll(X, Pf, fake_behaviorshortlist) 

## but now i want to optimize the P (so like its unknown)
## par is the intial values (starting point to optimize from)
## fn is the function to be maximized (our logLL function)
## then we can have further arguments that get passed to fn (so that would be our X?)
## control is scaling it bc optim likes to minimize and we want to optimize

## make the optim thing within another function to make it simpler to use

## fake initial matrix
initial_matrix_fake <- matrix(c(0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4), 
                              nrow = 3, ncol = 3)
row.names(initial_matrix_fake) <- fake_behaviorshortlist
colnames(initial_matrix_fake) <- fake_behaviorshortlist
```


## V.2 Function Code
```{r}
fit_MM <- function(X, behavior_list, par = matrix(1/length(behavior_list), 
                                                  nrow = length(behavior_list), 
                                                  ncol = length(behavior_list) - 1)){
  fit <- optim(par = par, fn = function(par, X){
    if(any(par < 0)) return(-Inf)
    if(any(par > 1)) return(-Inf)
    Pf <- matrix(par, nrow = length(behavior_list))
    if(any(rowSums(Pf) > 1)) return(-Inf)
    Pf <- cbind(Pf, 1 - rowSums(Pf))
    rownames(Pf) <- colnames(Pf) <- behavior_list
    get_ll(X, Pf, behavior_list)}, X = X, control = c(fnscale = -1, maxit = 5000))
  
  out <- fit$par
  out <- cbind(out, 1 - rowSums(out))
  out2 <- fit$convergence
  rownames(out) <- colnames(out) <- behavior_list
  return(fit)
}
```


## V.3 Applications/Testing

- trying different numbers of behaviors & different length focals to see where it breaks (it broke immediatly oops)

### Entire Focal
- nope :)
```{r}
## throwing entire focal in there - returned a uniform 12x12 matrix (didnt even try??)
test <- fit_MM(focal_10, behaviorshortlist)
test
```

### 3 behaviors
- works great
```{r}
## 3 behaviors - works really well
test3 <- fit_MM(X, fake_behaviorshortlist)
test3 

tm3 <- matrixfunct(X, fake_behaviorshortlist)
tm3
```

### 4 behaviors
- oop we broke, that didn't take long
- but still no warnings or errors....
- EDIT: rowwise now works better here
```{r}
## 4 behaviors - works but not accurate??
fake_behaviors4 <- c("move", "feed", "vigilance", "move", "sleep", "vigilance",
                     "feed", "sleep", "move", "sleep", "move", "vigilance", "sleep")
fake_duration4 <- c(5, 10, 10, 3, 120, 30, 45, 140, 30, 200, 80, 100, 80) 
fake_data4 <- data.frame(fake_duration4, fake_behaviors4)
colnames(fake_data4) <- c("TimeSpent", "Behavior") 
fake_behaviorlist4 <- c("move", "sleep", "feed", "vigilance")

test4 <- fit_MM(fake_data4, fake_behaviorlist4)
test4

## accuracy check
tm4 <- matrixfunct(fake_data4, fake_behaviorlist4)
tm4
```

### 5 behaviors
- seems to be just sticking close to the uniform and is heading towards the just returning uniform, why?????? - not enough information in data set (power issue!)
- loss of accuracy, better when we do it rowwise
```{r}
## 5 behaviors
fake_behaviors5 <- c("move", "feed", "aggresive", "vigilance", "move", "sleep", 
                     "vigilance",
                     "feed", "sleep", "move", "sleep", "move", "aggresive", "vigilance",
                     "sleep", "move", "feed", "move", "feed", "aggressive", "move",
                     "aggressive", "move", "feed", "move", "sleep")
fake_duration5 <- c(10, 20, 7, 10, 5, 140, 30, 25, 250, 30, 30, 60, 15, 10, 200, 23, 78, 
                    20, 45, 90, 20, 10, 45, 45, 30, 10) 
fake_data5 <- data.frame(fake_duration5, fake_behaviors5)
colnames(fake_data5) <- c("TimeSpent", "Behavior") 
fake_behaviorlist5 <- c("move", "sleep", "feed", "vigilance", "aggressive")

test5 <- fit_MM(fake_data5, fake_behaviorlist5)
test5

## accuracy check 
tm5 <- matrixfunct(fake_data5, fake_behaviorlist5)
tm5
```

```{r}
## testing 5 with a really long fake focal to see if it is a power analysis thing
## 5 behaviors
fake_behaviors5.0 <- c("move", "feed", "aggresive", "vigilance", "move", "sleep", "vigilance",
                     "feed", "sleep", "move", "sleep", "move", "aggresive", "vigilance",
                     "sleep", "move", "feed", "move", "feed", "aggressive", "move",
                     "aggressive", "move", "feed", "move", "sleep", "move", "feed", "aggresive", 
                     "vigilance", "move", "sleep", "vigilance",
                     "feed", "sleep", "move", "sleep", "move", "aggresive", "vigilance",
                     "sleep", "move", "feed", "move", "feed", "aggressive", "move",
                     "aggressive", "move", "feed", "move", "sleep", "move", "feed", "aggresive", 
                     "vigilance",
                     "move", "sleep", "vigilance",
                     "feed", "sleep", "move", "sleep", "move", "aggresive", "vigilance",
                     "sleep", "move", "feed", "move", "feed", "aggressive", "move",
                     "aggressive", "move", "feed", "move", "sleep", "move", "feed", "aggresive", 
                     "vigilance",
                     "move", "sleep", "vigilance",
                     "feed", "sleep", "move", "sleep", "move", "aggresive", "vigilance",
                     "sleep", "move", "feed", "move", "feed", "aggressive", "move",
                     "aggressive", "move", "feed", "move", "sleep", "move", "feed", "aggresive", 
                     "vigilance",
                     "move", "sleep", "vigilance",
                     "feed", "sleep", "move", "sleep", "move", "aggresive", "vigilance",
                     "sleep", "move", "feed", "move", "feed", "aggressive", "move",
                     "aggressive", "move", "feed", "move", "sleep", "move", "feed", "aggresive", 
                     "vigilance",
                     "move", "sleep", "vigilance",
                     "feed", "sleep", "move", "sleep", "move", "aggresive", "vigilance",
                     "sleep", "move", "feed", "move", "feed", "aggressive", "move",
                     "aggressive", "move", "feed", "move", "sleep")
fake_duration5.0 <- c(10, 20, 7, 10, 5, 140, 30, 25, 250, 30, 30, 60, 15, 10, 200, 23, 78, 20, 
                    45, 90, 20, 10, 45, 45, 30, 10, 10, 20, 7, 10, 5, 140, 30, 25, 250, 30, 30, 60, 15, 10,
                    200, 23, 78, 20, 
                    45, 90, 20, 10, 45, 45, 30, 10, 10, 20, 7, 10, 5, 140, 30, 25, 250, 30, 30, 60, 15, 10,
                    200, 23, 78, 20, 
                    45, 90, 20, 10, 45, 45, 30, 10, 10, 20, 7, 10, 5, 140, 30, 25, 250, 30, 30, 60, 15, 10,
                    200, 23, 78, 20, 
                    45, 90, 20, 10, 45, 45, 30, 10, 10, 20, 7, 10, 5, 140, 30, 25, 250, 30, 30, 60, 15, 10,
                    200, 23, 78, 20, 
                    45, 90, 20, 10, 45, 45, 30, 10, 10, 20, 7, 10, 5, 140, 30, 25, 250, 30, 30, 60, 15, 10,
                    200, 23, 78, 20, 
                    45, 90, 20, 10, 45, 45, 30, 10) 
fake_data5.0 <- data.frame(fake_duration5.0, fake_behaviors5.0)
colnames(fake_data5.0) <- c("TimeSpent", "Behavior") 
fake_behaviorlist5 <- c("move", "sleep", "feed", "vigilance", "aggressive")

test5.0 <- fit_MM(fake_data5.0, fake_behaviorlist5, par = initial)
test5.0

## accuracy check 
tm5.0 <- matrixfunct(fake_data5.0, fake_behaviorlist5)
tm5.0

behavior_list <- fake_behaviorlist5

initial <- 0.1*(1/(length(behavior_list) - 1))*matrix(1, nrow = length(behavior_list), ncol = length(behavior_list)) + (0.9 - (0.1*1/(length(behavior_list) - 1)))*diag(length(behavior_list))

initial <- initial[, 1:(length(behavior_list)-1)]
```

______________________________________________________________________

# VI. get_ll_row

## VI.1 function

```{r}
# for a fixed row_behavior = b1, find likelihood component
get_ll_row <- function(data, p_row, row_behavior, behavior_list){
  Yduration <- matrix(NA, nrow = 1, ncol = length(behavior_list))
  rownames(Yduration) <- row_behavior
  colnames(Yduration) <- behavior_list

  denominator <- sum(data$TimeSpent[data$Behavior == row_behavior]) -
    as.numeric(tail(data$Behavior, 1) == row_behavior)
  
  row_ind <- which(data$Behavior == row_behavior)
  
  for(b2 in behavior_list){
    if(row_behavior == b2){
      numerator <- denominator - sum(data$Behavior == row_behavior) + 
        as.numeric(tail(data$Behavior, 1) == row_behavior) 
    } else { 
      numerator <- sum(data$Behavior[row_ind + 1] == b2, na.rm = T)
    }
    Yduration[1,b2] <- numerator
  }
  
  LogL <- sum((log(p_row)*Yduration)[Yduration>0])
  
  if(is.na(LogL)){
    return(-Inf)
  } else {
    return(LogL)
  }
}
```

## VI.2 testing 

```{r}
## test w/5 behaviors
fake_p_row5 <- matrix(c(1/5, 1/5, 1/5, 1/5, 1/5), nrow = 1, ncol = 5)

test5.1 <- get_ll_row(fake_data5, fake_p_row5, "feed", fake_behaviorlist5)
## tentatively works?? its giving a number but like what does ll even mean lol
```


# VII. Row Optimization for fit_MM

- adds a condition for by row or by whole matrix 
- NOTE: this replaced the old fit_MM from before


## VII.1 Function Code
```{r}
## still need to add uncertainty

fit_MM <- function(data, behavior_list, par = matrix(1/length(behavior_list), 
                                                     nrow = length(behavior_list), 
                                                     ncol = length(behavior_list) - 1), 
                   maxit = 500, rowwise = T){
  if(!isTRUE(rowwise)){
    fit <- optim(par = par, method = "SANN" ,fn = function(par, data){
      if(any(par < 0)) return(-Inf)
      if(any(par > 1)) return(-Inf)
      Pf <- matrix(par, nrow = length(behavior_list))
      if(any(rowSums(Pf) > 1)) return(-Inf)
      Pf <- cbind(Pf, 1 - rowSums(Pf))
      rownames(Pf) <- colnames(Pf) <- behavior_list
      get_ll(X, Pf, behavior_list)}, data = data, control = c(fnscale = -1, maxit = maxit))
    
    out <- fit$par
    out <- cbind(out, 1 - rowSums(out))
    rownames(out) <- colnames(out) <- behavior_list
    return(out)
    
  } else if(isTRUE(rowwise)){
    out <- matrix(NA, nrow = length(behavior_list), ncol = length(behavior_list))
    rownames(out) <- colnames(out) <- behavior_list
    rownames(par) <- behavior_list
    for(b1 in behavior_list){
      par_row <- par[b1, ]
      fit <- optim(par = par_row, method = "SANN", fn = function(par, data){
        if(any(par < 0)) return(-Inf)
        if(any(par > 1)) return(-Inf)
        if(sum(par) > 1) return(-Inf)
        p_row <- c(par, 1 - sum(par))
        names(p_row) <- behavior_list
        get_ll_row(X, p_row, row_behavior = b1, behavior_list)}, data = data,  
        control = c(fnscale = -1, maxit = maxit))
   
       row_out <- fit$par
       row_out <- c(row_out, 1 - sum(row_out))
      
       out[b1, ] <- row_out
    }
    
    return(out)
  }
}
```

## VII.2 Testing (or just use the tests from V.3 bc its the same function name)
```{r}
## testing w/3 behaviors
test3 <- fit_MM(X, fake_behaviorshortlist)
test3 

tm3 <- matrixfunct(X, fake_behaviorshortlist)
tm3
```

_________________________________________________________________________

# VIII. Adding Covariates

### things to add but like its not working anyway rn

- Adding confidence intervals (hessian thing)
- Add uncertainty/predictors (add something to code before get_ll??)
- Map covariates to P


```{r}
## i am bailing on this and going to try to just work from a single example instead
## idk what happened here i am way more lost than i was a week ago
cov2prob <- function(data, Betas, behavior_list){
  X <- model.matrix(~ TimeSpent + Behavior + Habitat, data = data)
      ## is X supposed to have the behaviors?????? 
      ## is it just like the habitat covariate dummy that is supposed to be there??????
  B <- length(behavior_list)
  
  P_i <- c() ## idk what i am supposed to fill this with to get a BxB
  
  # does X go to T as in # of seconds in the focal or number of focals?
  for (i in 1:length(data)){
     Xt <- X[i, ] ## X for a single time points
      ## but we said we are assuming X is a vector that stays the same bc we are now working based on focals
     ## so idk what X is actually? I think I am looping over the wrong thing
     eta_ij <- matrix(NA, nrow = length(data), ncol = B) ## my dimensions are wack
                  ## not sure about the ncol??  
     for (j in 1:B){
      eta_ij[j, ] <- exp(t(Xt)*Beta[i,j]) ## still confused on beta
      P_i <- c(P_i, eta_ij/rowsum(eta_ij))
        ## i think this has to be inside this loop so then it will be of length B?
            ## not the length of the data
            ## hot take idk whats happening here
            ## i am more confused than i was a week ago
            ## none of this is looping right
            ## idek if im defining things as they should be
     }
    }
  return(P_i) ## this should be returning a BxB matrix???? idk 
}

## use the cov2prob function in a new version of the get_ll function that uses the row version?
get_ll_new <- function(Y, data, Betas, behavior_list){ ## wtf is Y
  B <- length(behavior_list)
  for (i in 1:B){
    for (t in 1:T){ ## T is the number of focals
      ## cov2prob(Betas[i, ])
      ## use get_ll_row
    }
    ## sum ll over focals
  }
}
```


```{r}
## trying to work off an example (total fail)

## sample set
fake_behaviors5.2 <- c("move", "feed", "aggresive", "vigilance", "move", "sleep", 
                     "vigilance","feed", "sleep", "move", "sleep", "move", "aggresive", "vigilance",
                     "sleep", "move", "feed", "move", "feed", "aggressive", "move",
                     "aggressive", "move", "feed", "move", "sleep")
fake_duration5.2 <- c(10, 20, 7, 10, 5, 140, 30, 25, 250, 30, 30, 60, 15, 10, 200, 23, 78, 
                    20, 45, 90, 20, 10, 45, 45, 30, 10) 
fake_category5.2 <- c(rep("jalan", 15), rep("hutan", 11))
fake_focal5.2 <- c(rep("1", 15), rep("2", 11))

fake_data5.2 <- data.frame(fake_duration5.2, fake_behaviors5.2, fake_category5.2, fake_focal5.2)
colnames(fake_data5.2) <- c("TimeSpent", "Behavior", "Habitat", "FocalID")


fake_focal5.2.1 <- isolate.focal(fake_data5.2, 1)
fake_focal5.2.2 <- isolate.focal(fake_data5.2, 2)

## exampleX.5.2.1 <- model.matrix(~ Habitat, data = fake_focal5.2.1)
## so that no longer makes sense bc we only have 1 level for the predictors, do we just assign 0 or 1 arbitrarily now????

## wait but we said that we are now working with the assumption that the predictors stay the same for each focal so we dont switch between habitats (adding a column for focal # to the fake data) 



### betas!
## Bi is a B x M matrix (B is # behaviors, M is # of predictors)
## so we have 5 behaviors here and 1 predictor (forest/road), so 5 rows and 1 column?

fake_betas <- matrix(rnorm(5), nrow = 5) ## this needs to be an array now? 
                                         ## but we pull out a single matrix

X_test <- c(1, 1) # intercept, jalan?
## 0 for hutan, 1 for jalan? should i add in another variable thats like monkey name so X isnt just a single number (we still have the intercept)
## i have lost what X is supposed to be
## its like the covariates right??? with dummy variables??
## and then betas give the weights for it or something?????

## i think i still dont understand how to define the things i am working with well enough to actually execute this 
```


- use get_ll_row
  - p_row is now a matrix that changes in time
  - jk need to redo it?? or no idk

- adding by focal (T) to simplify Xs (in each block the predictors stay the same)
- t is now a focal indicator

- get the cov2prob to work
- assuming x is a vector that is staying the same

cov2prob in the get_ll function?? then just pull the row you want
cov2prob based on a single indicator



this made sense in the meeting and now im looking at it and have no idea

bestie i have 100% lost the plot here :)
